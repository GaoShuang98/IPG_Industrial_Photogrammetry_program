#! /usr/bin/env python
#  -*- coding: utf-8 -*-

#  Copyright (c) 2020. Lorem ipsum dolor sit amet, consectetur adipiscing elit.
#  Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.
#  Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.
#  Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.
#  Vestibulum commodo. Ut rhoncus gravida arcu.

#
# Support module generated by PAGE version 5.4
#  in conjunction with Tcl version 8.6
#    Jul 22, 2020 09:27:22 PM CST  platform: Windows NT
#    Jul 22, 2020 09:43:15 PM CST  platform: Windows NT

import sys
import os
from tkinter import filedialog
import PIL
from PIL import Image, ImageTk
import numpy as np
import pylab
import copy
import matplotlib.pyplot as plt
import math
from tkinter import messagebox
import numba
import time
import VTK_STL_TXT_visualization


global imgs  # 全局变量
imgs = []


# ----------------------------------------------------------------------------------------------------------------------
class SETTING_PARAMETER:  # 设置参数
    """
    摄影测量参数类（一个对象，不用实例化，类似于结构体）
    """
    code_prefix_name = "Code"
    pt_proximity_factor = 6
    search_parameter = 6
    match_pix_error = 1
    line_error = 1.4
    reject_factor = 2
    cross_error = 0.3
    affine_error = 0.2


class CAMERA:
    """
    相机参数
    """
    def __init__(self, f=0, x0=0.0, y0=0.0, k1=0.0, k2=0.0, k3=0.0, p1=0.0, p2=0.0, b1=0.0, b2=0.0, res_width=0, res_height=0, grid_correct=0):
        self.f = f
        self.x0 = x0
        self.y0 = y0
        self.k1 = k1
        self.k2 = k2
        self.k3 = k3
        self.p1 = p1
        self.p2 = p2
        self.b1 = b1
        self.b2 = b2
        self.res_width = res_width
        self.res_height = res_height
        self.grid_correct = grid_correct
    f = 24.46205
    x0 = -0.06658
    y0 = -0.02919
    k1 = 1.644e-004
    k2 = -2.393e-007
    k3 = -7.569e-013
    p1 = -3.378e-005
    p2 = -3.231e-007
    b1 = -1.078e-005
    b2 = 1.431e-005
    # x0 = 0
    # y0 = 0
    # k1 = 0
    # k2 = 0
    # k3 = 0
    # p1 = 0
    # p2 = 0
    # b1 = 0
    # b2 = 0
    res_width = 7360  # 单位/pix
    res_height = 4912  # 单位/pix
    grid_correct = 0
    pix_length = 0.00488  # 单位/mm


# 图片类，其中targets、code_target继承其它类的属性一区分不哦那个像片的编码标志与标志点的集合
class IMAGE:
    def __init__(self, path=-1, img='', width=-1, height=-1, gray=-1, array=-1, targets=False, code_target=-1, file_name=None):
        self.path = path
        self.img = img
        self.width = width
        self.height = height
        self.gray = gray
        self.array = array
        self.targets = targets  # 继承每张图片中class 的IMAGE_TARGET的参数
        self.code_target = code_target
        self.file_name = file_name


class SCAN_PARAMETER:  # 图像扫描参数
    shape = 0.1  # 形状参数  宽高比
    black_white_min_limit = 0.4  # 黑白比最小值
    black_white_max_limit = 1.4  # 黑白比最大值
    over_exposure = 0.3  # 过曝率
    width_max_limit = 80  # x方向最大像素数
    width_min_limit = 3  # x方向最小像素数
    height_max_limit = 80  # y方向最大像素数
    height_min_limit = 3  # y方向最小像素数
    grid_threshold = 5  # 梯度阈值
    brightness = 20  # 亮度
    pix_num_min_limit = 18  # 像素数最小值
    pix_num_max_limit = 800  # 像素数最大值
    deviation = 5  # 偏离 背景一致性
    gain = 0.05  # 获得                                                                              
    pace = 1  # 步距


class IMAGE_TARGET:  # 图像像点标志类
    def __init__(self, screen_name='None', code_name=None, code_center=False, index=0, width=0, height=0, b_code=False,
                 b5code=False, code_num=0, s5code_name=0, match_num=0, dx=0, dy=0, du=0, dv=0, cor_x=0, cor_y=0, resix=0
                 , resiy=0):
        self.screen_name = screen_name  # （字符型）0 显示在屏幕上的名字
        self.code_name = code_name  # （字符型）1  所属的编码点号
        self.code_center = code_center  # （布尔值）2 判断是否为编码点中心点
        self.index = index  # 像点序号（整型）3  该点在图像所有点的序号
        self.width = width  # 像点宽度（双精度型）4
        self.height = height  # 像点高度（双精度型）5
        self.b_code = b_code  # 判断像点是否为编码点 （布尔值）6  判断是否为编码点中的点
        self.b5code = b5code  # 编码点中的五点编号 （布尔值）7  判断是否为编码点中的5点类
        self.code_num = code_num   # 编码点 （整型）8  编码点的序号（1 2 3 4 5 6 7 8）
        self.s5code_name = s5code_name  # 临时用（字符型）9
        # ----------------------------------------以上为临时用
        self.match_num = match_num  # 整型  10
        self.dx = dx  # 11  # 像点畸变改正后的像点x坐标
        self.dy = dy  # 12  # 像点畸变改正后的像点y坐标
        self.du = du  # 13  # 像点畸变改正前的像点x坐标
        self.dv = dv  # 14  # 像点畸变改正前的像点y坐标
        self.cor_x = cor_x  # 15
        self.cor_y = cor_y  # 16
        self.resix = resix  # 像点参与计算的残差 17
        self.resiy = resiy  # 像点参与计算的残差 18


class SEGMENT:
    def __init__(self, index=-1, start=-1, end=-1, target_num=-1, row=-1):
        self.index = index
        self.start = start
        self.end = end
        self.target_num = target_num
        self.row = row


class TARGET_ASSEMBLY:
    """
    标志点片段索引结构体
    """
    def __init__(self, segment_num=0, value=True, ID=-1, du=-1, dv=-1, shape=0, black_white=0, over_exposure=False, max_gray=0,
                 pix_num=0, width=0, height=0, one_target_segments=None):
        self.segment_num = segment_num  # 片段数  0
        self.value = value  # 目标点是否是可用标志  1
        self.id = ID  # 目标点ID  2
        self.du = du  # 标志点行列号  3
        self.dv = dv  # 4
        self.shape = shape  # 圆形度  5
        self.black_white = black_white  # 黑白比  6
        self.over_exposure = over_exposure  # 过度曝光率  7
        self.max_gray = max_gray  # 最大灰度值  8
        self.pix_num = pix_num  # 像素数  9
        self.width = width  # 宽  10
        self.height = height  # 高  11
        self.one_target_segments = one_target_segments  # 标志点所包括的片段list  12


class SHOT_STATION():
    """
    相机摄站结构体
    """
    def __init__(self, value=None, img_target=None, Xs=None, Ys=None, Zs=None, Rx=None, Ry=None, Rz=None, q0=None,
                 q1=None, q2=None, q3=None, a1=None, a2=None, a3=None, b1=None, b2=None, b3=None, c1=None, c2=None,
                 c3=None, RMSx=None, RMSy=None, RMS=None):
        self.value = value
        self.img_target = img_target
        self.Xs = Xs
        self.Ys = Ys
        self.Zs = Zs
        self.Rx = Rx
        self.Ry = Ry
        self.Rz = Rz
        self.q0 = q0
        self.q1 = q1
        self.q2 = q2
        self.q3 = q3
        self.a1 = a1
        self.a2 = a2
        self.a3 = a3
        self.b1 = b1
        self.b2 = b2
        self.b3 = b3
        self.c1 = c1
        self.c2 = c2
        self.c3 = c3
        self.RMSx = RMSx
        self.RMSy = RMSy
        self.RMS = RMS


class POINT_3D():
    """
    3D点结构体
    """
    def __init__(self, value=None, match=None, X=None, Y=None, Z=None, cal_X=None, cal_Y=None, cal_Z=0, RMS=None, RMSx=None
                 , RMSy=None, station_index_list=None, img_point_index_list=None, img_point_list=None, shot_sta_list=None):
        self.value = value
        self.match = match  # 匹配号
        self.X = X
        self.Y = Y
        self.Z = Z
        self.cal_X = cal_X  # 改正后的X
        self.cal_Y = cal_Y
        self.cal_Z = cal_Z
        self.RMS = RMS
        self.RMSx = RMSx  # 像点残差RMSx
        self.RMSy = RMSy
        self.station_index_list = station_index_list
        self.img_point_index_list = img_point_index_list
        self.img_point_list = img_point_list
        self.shot_sta_list = shot_sta_list

# -----------------------------------------------------------------------------------
try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True


def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui  # 调用GUI中的部件如ScrolledText1中插入文字，则用该变量调用
    top_level = top
    root = top
    w.import_camera.config(state="disabled")


def auto_processing():
    """自动测量模块，自动进行图像扫描、定向、像点匹配、光束法平差"""
    print('IPG_GUI_support.auto_processing')
    sys.stdout.flush()


def bundle_adjustment():
    """光束法平差模块"""
    print('IPG_GUI_support.bundle_adjustment')
    sys.stdout.flush()


def bundle_adjustment_results():
    """平差结果，查询平差结果界面"""
    print('IPG_GUI_support.bundle_adjustment_results')
    sys.stdout.flush()


def display_3d_data():
    """三维显示计算完成后的点三维数据"""
    print('IPG_GUI_support.display_3d_data')
    VTK_STL_TXT_visualization.create()


def import_camera():
    """导入相机文件"""
    print('IPG_GUI_support.import_camera')
    """加载相机文件函数"""
    file_path = tk.filedialog.askopenfilename()
    with open(file_path, 'r') as camera_file:  # 相机文件为txt格式
        txt_stream = camera_file.readlines()
        print(txt_stream)
        w.Scrolledtext1.insert('end', ' 相机文件参数：\n')
        # 将相机文件中的参数提取出来
        for i in txt_stream:
            if 'width=' in i:
                CAMERA.res_width = int(i.replace('width=', '').replace('\n', ''))
                print(' 相机像素宽为：', CAMERA.res_width)
            elif 'height=' in i:
                CAMERA.res_height = int(i.replace('height=', '').replace('\n', ''))
                print(' 相机像素高为：', CAMERA.res_height)
            elif 'px=' in i:
                CAMERA.pix_size_x = float(i.replace('px=', '').replace('\n', ''))
                print(' 单个像素x尺寸：', CAMERA.pix_size_x)
            elif 'py=' in i:
                CAMERA.pix_size_y = float(i.replace('py=', '').replace('\n', ''))
                print(' 单个像素y尺寸：', CAMERA.pix_size_y)
            elif 'f=' in i:
                CAMERA.df = float(i.replace('f=', '').replace('\n', ''))
                print(' 相机焦距为：', CAMERA.df)
            elif 'x0=' in i:
                CAMERA.dx0 = float(i.replace('x0=', '').replace('\n', ''))
                print(' x0:', CAMERA.dx0)
            elif 'y0=' in i:
                CAMERA.dy0 = float(i.replace('y0=', '').replace('\n', ''))
                print(' dy0:', CAMERA.dy0)
            elif 'k1=' in i:
                CAMERA.dk1 = float(i.replace('k1=', '').replace('\n', ''))
                print(' k1:', CAMERA.dk1)
            elif 'k2=' in i:
                CAMERA.dk2 = float(i.replace('k2=', '').replace('\n', ''))
                print(' k2:', CAMERA.dk2)
            elif 'k3=' in i:
                CAMERA.dk3 = float(i.replace('k3=', '').replace('\n', ''))
                print(' k3:', CAMERA.dk3)
            elif 'p1=' in i:
                CAMERA.dp1 = float(i.replace('p1=', '').replace('\n', ''))
                print(' p1:', CAMERA.dp1)
            elif 'p2=' in i:
                CAMERA.dp2 = float(i.replace('p2=', '').replace('\n', ''))
                print(' p2:', CAMERA.dp2)
            elif 'b1=' in i:
                CAMERA.db1 = float(i.replace('b1=', '').replace('\n', ''))
                print(' b1:', CAMERA.db1)
            elif 'b2=' in i:
                CAMERA.db2 = float(i.replace('b2=', '').replace('\n', ''))
                print(' b2:', CAMERA.db2)
            elif 'gridcorrect=' in i:
                CAMERA.grid_correct = float(i.replace('gridcorrect=', '').replace('\n', ''))
                print(' gridcorrect:', CAMERA.grid_correct)
            w.Scrolledtext1.insert('end', i)
    if imgs[0].array.shape[0] != CAMERA.res_height or imgs[0].array.shape[1] != CAMERA.res_width:  # 判断相机文件是否符合所导入的图像要求
        tk.messagebox.showinfo('警告！', '相机文件中图像尺寸与实际图像不匹配。')
        import_camera()

def correct_img_point(du, dv, img_width, img_height):
    """
    以10参数模型为模型，计算单个像点的畸变，input：改正前像点坐标 output：改正后的像点坐标
    """
    x = (du - img_width / 2) * CAMERA.pix_length  # 将像素单位化作mm单位坐标
    y = - (dv - img_height / 2) * CAMERA.pix_length

    x_x0 = x - CAMERA.x0  # x-x0
    y_y0 = y - CAMERA.y0  # y-y0
    r2 = x_x0 * x_x0 + y_y0 * y_y0  # (x-x0)*(x-x0)+(y-y0)*(y-y0)

    jing_x = CAMERA.k1 * x_x0 * r2 + CAMERA.k2 * x_x0 * r2 * r2 + CAMERA.k3 * x_x0 * r2 * r2 * r2
    jing_y = CAMERA.k1 * y_y0 * r2 + CAMERA.k2 * y_y0 * r2 * r2 + CAMERA.k3 * y_y0 * r2 * r2 * r2
    qie_x = CAMERA.p1 * (r2 + 2 * x_x0 * x_x0) + 2 * CAMERA.p2 * x_x0 * y_y0
    qie_y = CAMERA.p2 * (r2 + 2 * y_y0 * y_y0) + 2 * CAMERA.p1 * x_x0 * y_y0
    xiang_x = CAMERA.b1 * x_x0 + CAMERA.b2 * y_y0
    xiang_y = 0

    cor_x = x + jing_x + qie_x + xiang_x
    cor_y = y + jing_y + qie_y + xiang_y
    # print('矫正之前像点坐标：x：{} y：{}'.format(x, y))
    # print('矫正之后像点坐标：x：{} y：{}'.format(cor_x, cor_y))
    return cor_x, - cor_y  # 由于像素坐标系与像平面坐标系不同因此导出－dy

def all_img_point_correct():
    """
    纠正所有图像像点畸变，若判断图像没有扫描，则不纠正
    """
    for img in imgs:
        if img.targets:  # 如果图像尚未扫描，跳过
            for pt in img.targets:
                pt.dx, pt.dy = correct_img_point(pt.du, pt.dv, CAMERA.res_width, CAMERA.res_height)  # 输出以图像中心为原点的坐标系的改正后的像点坐标


def single_img_point_correct(single_img):
    """
    纠正单张图像像点畸变
    """

    for pt in single_img.targets:
        pt.dx, pt.dy = correct_img_point(pt.du, pt.dv, CAMERA.res_width, CAMERA.res_height)
    # plt.imshow(single_img.img, cmap='gray')
    plt.figure()
    plt.title('Image points vector deviation')
    plt.xlabel('x-pix')
    plt.ylabel('y-pix')
    plt.xlim(0, 7360)
    plt.ylim(0, 4912)
    # plt.xticks([]), plt.yticks([])
    # plt.imshow(pylab.array(single_img.img))
    for aim in single_img.targets:
        # plt.plot(aim.du, -aim.dv, 'b+')  # ‘r+’ 为在影像点中心显示红色十字  ，同样‘g+’，‘w+’ 等
        # plt.text(aim.du, aim.dv, '{:^.3f}pix'.format(math.sqrt((- aim.dy*1000 + CAMERA.res_height/2-aim.dv) * (- aim.dy*1000 + CAMERA.res_height/2-aim.dv) + (aim.dx*1000 + CAMERA.res_width/2-aim.du) * (aim.dx*1000 + CAMERA.res_width/2-aim.du))), color='blue', fontsize=5)
        plt.quiver(aim.du, aim.dv, aim.dx, aim.dy, color='green', scale=0.09, scale_units='xy', width=0.001, headwidth=4)
        # plt.plot(aim.dx * 1000, -aim.dy * 1000, 'g+')
    plt.show()


# ------------------------------------------------------------------------------
def import_single_img(url, file_name):
    """
    加载单个图像，批量加载的函数对其进行调用， input：url，file_name output: img
    """
    img = IMAGE()
    img.img = PIL.Image.open(url)
    img.width, img.height = img.img.size  # 获取图片宽高值
    # img.gray = img.img.convert('L')  # 注意其中将图片黑白化的参数为’L‘，并不是’1‘若是1则灰度矩阵将是False和True
    # img.array = pylab.array(img.gray)  # 将图像灰度矩阵赋值与img对象（属于IMAGE类）
    img.file_name = file_name
    img.path = url
    return img

# 变换图片大小->load_img()
def resize_img(w_box, h_box, img):
    """
    变换图片大小， input：画布长、宽、图像img
    """
    img_f = copy.deepcopy(img)
    w, h = img.size  # 获取图像的原始大小
    f1 = 1.0 * w_box / w
    f2 = 1.0 * h_box / h
    factor = min([f1, f2])
    width = int(w * factor)
    height = int(h * factor)
    return img_f.resize((width, height), Image.ANTIALIAS)

def resize_point_pos_du_dv(w_box, h_box, img, point_pos_assembly):
    """
    变换点dx dy 坐标尺寸大小，使适合画布大小，从而与变换过的图像匹配, input:画布长、宽，图像、点坐标集合
    """
    canvas_points_pos = copy.deepcopy(point_pos_assembly)
    w, h = img.size  # 获取图像的原始大小
    f1 = 1.0 * w_box / w
    f2 = 1.0 * h_box / h
    factor = min([f1, f2])
    for i in range(len(canvas_points_pos)):
        canvas_points_pos[i].du *= factor
        canvas_points_pos[i].dv *= factor
    return canvas_points_pos

def resize_point_pos_dx_dy(w_box, h_box, img, point_pos_assembly):
    """
    变换点dx dy 坐标尺寸大小，使适合画布大小，从而与变换过的图像匹配, input:画布长、宽，图像、点坐标集合
    """
    canvas_points_pos = copy.deepcopy(point_pos_assembly)
    w, h = img.size  # 获取图像的原始大小
    f1 = 1.0 * w_box / w
    f2 = 1.0 * h_box / h
    factor = min([f1, f2])
    for i in range(len(canvas_points_pos)):
        canvas_points_pos[i].dx = (canvas_points_pos[i].dx  * 1000 + CAMERA.res_width / 2) * factor  # 将像素单位的x、y坐标转化为毫米单位x、y
        canvas_points_pos[i].dy = (canvas_points_pos[i].dy  * 1000 + CAMERA.res_height / 2) * factor
    return canvas_points_pos

# def wheel_zoomer(event):
#     """监听鼠标滚轮事件，同时缩放画布中图像与点"""
#     print('wheel_zoomer()!')
#     if event.delta > 0:
#         w.Canvas1.scale("all", event.x, event.y, 1.1, 1.1)
#     else:
#         w.Canvas1.scale('all', event.x, event.y, 0.9, 0.9)
#     w.Canvas1.mainloop()  # 一定要加循环


def draw_corrected_img_point():
    """
    绘制像点畸变校正后的像点中心
    """
    try:
        img_num = w.img_list.curselection()[0]  # 获得照片序号
        single_img_point_correct(imgs[img_num])
        canvas_point_pos = resize_point_pos_dx_dy(1202, 675, imgs[img_num].img, imgs[img_num].targets)
        for aim in canvas_point_pos:
            x = aim.dx  # ===============本程序所用坐标系与常规摄影测量坐标系相反，因此需注意反向使用坐标系=============
            y = aim.dy  # =================================================================================
            if aim.code_center:
                w.Canvas1.create_text((x, y), text='+', anchor='center', fill='yellow', tag='text')
                w.Canvas1.create_text((x + 1, y - 1), text=str(aim.screen_name), anchor='sw', fill='yellow', tag='text')
            # if aim.b5code:  # 要想显示编码点全部点号改为[7],只显示中间编码点号，改为[2]
            #     w.Canvas1.create_text((x, y), text='+', anchor='center', fill='green', tag='text')
            #w.Canvas1.create_text((x + 1, y - 1), text=str(aim.screen_name), anchor='sw', fill='green', tag='text')
            elif not aim.b5code:
                w.Canvas1.create_text((x, y), text='+', anchor='center', fill='green', tag='text')
    except IndexError:
        messagebox.showinfo('提示', '请确保图像框中图像名被选中！')
        w.Canvas1.mainloop()  # 一定要加循环，否则图片在画布上显示不出来

def export_img_points():
    """
    导出扫描过后的单张图像的像点坐标
    """
    try:
        img_num = w.img_list.curselection()[0]  # 获得照片序号
        single_img = imgs[img_num]
        for pt in single_img.targets:  # 遍历并矫正图像中每一个像点
            pt.dx, pt.dy = correct_img_point(pt.du, pt.dv, CAMERA.res_width, CAMERA.res_height)
        file_path = tk.filedialog.askdirectory()
        try:
            with open(file_path + '\\' + 'pic{}_points.txt'.format(img_num), 'w+') as img_points_txt:
                num = 0
                txt_file = []
                for aim in single_img.targets:
                    if aim.code_center:
                        x = aim.dx  # ===============本程序所用坐标系与常规摄影测量坐标系相反，因此需注意反向使用坐标系=============
                        y = aim.dy  # =================================================================================
                        # x = aim.du
                        # y = aim.dv
                        txt_file.append(str(aim.match_num) + '\t' + str(x) + '\t' + str(y) + '\n')
                        num += 1
                img_points_txt.write(str(num) + '\n')
                img_points_txt.writelines(txt_file)
            messagebox.showinfo('提示', '成功导出图像{}矫正后的像点坐标'.format(str(img_num)))
        except FileNotFoundError:
            pass
    except IndexError:
        messagebox.showinfo('提示', '请确保图像框中图像名被选中！')
        w.Canvas1.mainloop()  # 一定要加循环，否则图片在画布上显示不出来


def export_all_img_points():
    """
    扫描图像之后，导出所有图像点坐标
    """
    for img in imgs:
        for target in img.targets:
            target.dx, target.dy = correct_img_point(target.du, target.dv, CAMERA.res_width, CAMERA.res_height)
    root = tk.Tk()
    root.withdraw()
    file_path = tk.filedialog.askdirectory()
    for i in range(len(imgs)):
        try:
            with open(file_path + r'\img_points_' + str(i) + '.txt', 'w+') as img_points_txt:
                num = 0
                txt_file = []
                for aim in imgs[i].targets:
                    if aim.code_center:
                        x = aim.dx  # ===============本程序所用坐标系与常规摄影测量坐标系相反，因此需注意反向使用坐标系=============
                        y = aim.dy  # =================================================================================
                        # x = aim.du
                        # y = aim.dv
                        txt_file.append(str(aim.match_num) + '\t' + str(x) + '\t' + str(y) + '\n')
                        num += 1
                img_points_txt.write(str(num) + '\n')
                img_points_txt.writelines(txt_file)
        except FileNotFoundError:
            messagebox.showinfo('提示', 'FileNotFoundError！！！')
            pass

    messagebox.showinfo('提示', '成功导出所有图像矫正后的像点坐标')


def draw_point_center(img, point_center):  # 绘制畸变矫正之前的单点中心
    """
    将扫描后的点绘制到画布上，input：img， point_center, canvas
    """
    # canvas.delete('text')
    canvas_point_pos = resize_point_pos_du_dv(1202, 675, img, point_center)
    for aim in canvas_point_pos:
        x = aim.du  # ===============本程序所用坐标系与常规摄影测量坐标系相反，因此需注意反向使用坐标系=============
        y = aim.dv  # =================================================================================
        if aim.code_center:
            w.Canvas1.create_text((x, y), text='+', anchor='center', fill='yellow', tag='text')
            w.Canvas1.create_text((x + 1, y - 1), text=str(aim.screen_name), anchor='sw', fill='yellow', tag='text')
        # if aim.b5code:  # 要想显示编码点全部点号改为[7],只显示中间编码点号，改为[2]
        #     w.Canvas1.create_text((x, y), text='+', anchor='center', fill='green', tag='text')
            # w.Canvas1.create_text((x + 1, y - 1), text=str(aim.screen_name), anchor='sw', fill='green', tag='text')
        elif not aim.b5code:
            w.Canvas1.create_text((x, y), text='+', anchor='center', fill='red', tag='text')

def clear_canvas_point():
    """
    清空画布中的所有点
    """
    w.Canvas1.delete('text')
    w.menu.entryconfig(1, state='disable')
    w.menu.entryconfig(2, state='disable')
    w.menu.entryconfig(3, state='disable')

def list_box_click(event):
    """
    双击img_list触发该函数运行，功能获取listbox中在选的图像序号，将图像显示在画布Canvas1中
    """
    w.menu.entryconfig(0, state='normal')  # 使右键菜单：扫描图像 键有效
    w.menu.entryconfig(1, state='disable')
    w.menu.entryconfig(2, state='disable')
    w.menu.entryconfig(3, state='disable')
    w.Canvas1.delete('all')  # 把之前画布的照片删除掉
    img_1 = imgs[w.img_list.curselection()[0]]
    resized_img = resize_img(1202, 675, (img_1.img).convert('L'))
    photo = ImageTk.PhotoImage(resized_img)  # 利用PIL模块的PhotoImage打开
    w.Canvas1.create_image(0, 0, anchor='nw', image=photo, tag='photo')
    if img_1.targets:  # 判断以下有没有扫描出来的点，要是有就显示到画布上，同时激活像点坐标纠正选项
        draw_point_center(img_1.img, img_1.targets)
        w.menu.entryconfig(1, state='normal')
        w.menu.entryconfig(2, state='normal')
        w.menu.entryconfig(3, state='normal')
    w.Canvas1.mainloop()  # 一定要加循环，否则图片在画布上显示不出来

def import_imgs():
    """
    导入图像
    """
    print('IPG_GUI_support.import_imgs')
    imgs.clear()
    w.import_camera.config(state="normal")  # 使导入相机模块重新激活
    """加载图片函数"""
    w.img_list.delete(0, 'end')
    select_img = tk.Tk()  # 打开图像，获取图像位置
    select_img.withdraw()
    # img = IMAGE  # 建立IMAGE类的对象：img，此次定义成全局变量
    path = filedialog.askopenfilename()  # 获取图片位置
    w.Scrolledtext1.insert('end', '图像地址为：{}\n'.format(str(path)))
    dad_path = os.path.split(path)[0]  # 上级目录
    # w.Scrolledtext1.insert('end', '返回上级目录：{}\n'.format(dad_path))
    for file_name in os.listdir(dad_path):
        if file_name.endswith('.jpg') or file_name.endswith('.JPG'):  # 判断后缀是否为‘.jpg’
            imgs.append(import_single_img(dad_path + '/' + file_name, file_name))
    if imgs:
        for i in imgs:
            w.img_list.insert('end', i.file_name)
    else:
        messagebox.showinfo('tip', '所在路径中没有图像！')


# ----------------------------------------------------------------------------------------------------------
# 单行扫描
@numba.jit  # 利用numba.fit模块对性能进行优化，一张照片可以提升20倍
def scan_one_row(row_array, grad_threshold, target_width, min_gray):
    """
    对所导入的图像进行单行扫描，返回单行的片段list
    """
    start_pos = list()
    end_pos = list()
    step = 0  # 梯度值初始化为0
    scan_width = len(row_array) - 1
    max_gray_level = -1  # 灰度极大值
    mid_gray_level = -1.0  # 灰度平均值
    segment_index = 0  # 初始化片段编号
    start_pos_gray = -1  # 初始化起始位置灰度
    # 开始扫描遍历行中所有像素
    for i in range(scan_width):
        left_gray = int(row_array[i])
        right_gray = int(row_array[i + 1])
        if left_gray < min_gray:  # 最小像素灰度值为20
            left_gray = 0  # 小于20将左像素灰度置为0
        if right_gray < min_gray:
            right_gray = 0  # 小于20将右像素灰度置为0
        grad = left_gray - right_gray  # 计算梯度
        if step == 0:
            if grad < (0 - grad_threshold):  # 梯度大于梯度阈值，梯度阈值为5
                start_pos.append(i + 1)  # 增加起始位置
                start_pos_gray = right_gray
                step = 1  # 转变状态
        elif step == 1:
            if grad > 0:  # 灰度开始下降
                max_gray_level = left_gray
                mid_gray_level = int(start_pos_gray / 2.0 + max_gray_level / 2.0)
                step = 2
        else:  # 灰度下降时运行（即step==2时）
            if left_gray < mid_gray_level:
                if abs(
                        grad) < grad_threshold or left_gray < start_pos_gray or right_gray < 1:  # right < 1 不是left !!!!!!!!!
                    if (i - start_pos[segment_index]) > target_width * 5:  # 如果长度比标志点最宽限值的五倍还大，则扫描下一个
                        step = 0
                        i -= 1
                        continue
                    end_pos.append(i)
                    segment_index += 1
                    step = 0
                    i -= 1

    return segment_index, start_pos, end_pos  # 成功计算返回1

# 所有行扫描
def scan_all_row(img_array, gray_threshold, target_max_width, target_min_width, min_gray):
    """
    对图片所有行进行扫描函数，返回所有行的片段list
    """
    # print('img_size:', img_array.shape)
    row_index_f = list()
    height = img_array.shape[0]
    for i in range(height):  # 图像第i行灰度
        # print('扫描第{}行中---------------------------------------'.format(i))
        Segment_Index_rows = list()
        segment_num, start_pos_one_row, end_pos_one_row = scan_one_row(img_array[i], gray_threshold,
                                                                             target_max_width, min_gray)

        # 将扫描的片段存入list中
        if segment_num != 0:
            for j in range(segment_num):
                segment = SEGMENT()  # 其中定义segment[0]为start_pos,segment[1]为end_pos,segment[2]为row
                segment.start = start_pos_one_row[j]
                segment.end = end_pos_one_row[j]
                if segment.end - segment.start <= target_min_width:
                    continue
                segment.row = i
                # print('segment:', segment[0], segment[1], 'row_index:', segment[2])
                Segment_Index_rows.append(segment)
        if Segment_Index_rows != []:
            row_index_f.append(Segment_Index_rows)  # 将每行的片段索引添加至总行片段索引中
        del start_pos_one_row, end_pos_one_row, Segment_Index_rows  # 删除前面的留存的变量防止串值
    return row_index_f

# 行合并
def merge_rows(row_index_f):
    """
    对图片所有行片段进行合并，返回点list
    """
    target_list = [[] for i in range(9000)]  # 定义单张图片的像点属性list
    target_index_f = 0  # 控制单张图像中所有扫描出来的点的编号
    # 第一行所有片段分配编号
    for j in range(len(row_index_f[0])):
        row_index_f[0][j].target_num = j  # 第[3]索引元素文target_index row_index_f
        target_list[j].append(row_index_f[0][j])
        target_index_f = j
    # 合并所有行
    for i in range(1, len(row_index_f)):  # 第i行
        # print('合并第{}行中……'.format(row_index_f[i][0][2]))
        for j in range(len(row_index_f[i])):  # 第i行的第j个片段
            k = 0
            for k in range(len(row_index_f[i - 1])):  # i - 1行的片段遍历
                n = row_index_f[i - 1][k]  # 上一行的
                m = row_index_f[i][j]  # 下一行的
                s1 = n.start
                s2 = m.start
                e1 = n.end
                e2 = m.end
                min = s1
                max = e1
                if min > s2:
                    min = s2
                if max < e2:
                    max = e2
                dis1 = e1 - s1
                dis2 = e2 - s2
                dis = max - min
                if dis <= (dis1 + dis2) and m.row == n.row + 1:  # 找到同一个标志点，分配统一ID号，并添加
                    row_index_f[i][j].target_num = row_index_f[i - 1][k].target_num
                    # 将上一行的target_index值赋予下一行与上一行该片段相符合的片段的target_index中(括号内的内容)
                    target_list[row_index_f[i][j].target_num].append(row_index_f[i][j])
                    break
                elif dis <= dis1 + dis2 and m.row != n.row + 1:
                    target_index_f += 1
                    row_index_f[i][j].target_num = int(target_index_f)
                    target_list[row_index_f[i][j].target_num].append(row_index_f[i][j])
                    break
            if row_index_f[i][j].target_num == -1 and k == len(row_index_f[i - 1]) - 1:  # 如果前一行片段遍历完毕，都不符合要求（为新点）
                target_index_f += 1
                row_index_f[i][j].target_num = int(target_index_f)
                target_list[row_index_f[i][j].target_num].append(
                    row_index_f[i][j])  # 处理大图幅图像时此处出现问题：IndexError: list index out of range（是因为target_list容量小了）
    return target_index_f + 1, target_list

# 8点编码点识别
def read_8_code(target_list, target_number, search, line_error, cross_error, affine_error):
    """
    利用扫描后的点坐标，对编码点进行识别
    """

    def affine_8_code_error(code_5_point):
        """仿射变换写成矩阵形式：u = ax + by + c
                               v = dx + ey + f
            其中所求解为：a、b、c、d、e、f 六参数矩阵"""
        # 固定设计坐标
        dx = [36.4, 0, 0, 15.4, 16.1]
        dy = [36.4, 15.4, 0, 0, 16.1]

        # 最小二乘计算
        # 定义矩阵
        A = np.zeros((10, 6))  # 系数矩阵
        AT = np.zeros((6, 10))  # 系数矩阵转置
        ATA = np.zeros((6, 6))  # 法方程系数阵
        L = np.zeros((10, 1))  # 常数项
        ATL = np.zeros((6, 1))
        X = np.zeros((6, 1))  # 未知数改正数
        V = np.zeros((6, 1))  # 误差
        # 矩阵A和L赋值
        start = 1
        for s in range(5):
            mid = s * 12
            A[mid // 6][mid % 6] = code_5_point[s + start].du
            A[(mid + 1) // 6][(mid + 1) % 6] = code_5_point[s + start].dv
            A[(mid + 2) // 6][(mid + 2) % 6] = 1
            A[(mid + 9) // 6][(mid + 9) % 6] = code_5_point[s + start].du
            A[(mid + 10) // 6][(mid + 10) % 6] = code_5_point[s + start].dv
            A[(mid + 11) // 6][(mid + 11) % 6] = 1
            L[s * 2][0] = dx[s]
            L[s * 2 + 1][0] = dy[s]

        # 最小二乘解算
        AT = np.transpose(A)
        ATA = np.dot(AT, A)
        ATL = np.dot(AT, L)
        ATA = np.linalg.inv(ATA)
        X = np.dot(ATA, ATL)
        V = np.dot(A, X)
        V = V - L
        error = 0.0
        for er in range(10):
            error += V[er] * V[er]
        error = math.sqrt(error / 10)
        # print('affine X为', X)
        return 1, error, X

    def code_bin_to_dec(bin, n):
        """
        点分布名称转换成十进制编码数：例：2 ^ 3其中3为点的编号，一个点变成2的3次方返回此值（lDec）（pBin为识别出来的点编号）
        """
        dec = 0
        for b in range(n):
            if bin[b] == 1:
                dec += 2 ** b
        return dec


    def affine(initial_5_code_pos_f, affine_para_f):  # 仿射变换
        """
        仿射变换，根据放射变换参数affine_para，与点dx dy坐标，计算出在编码点坐标系中的坐标
        """
        dx_f = initial_5_code_pos_f.du
        dy_f = initial_5_code_pos_f.dv
        dx2 = dx_f * affine_para_f[0] + dy_f * affine_para_f[1] + affine_para_f[2]
        dy2 = dx_f * affine_para_f[3] + dy_f * affine_para_f[4] + affine_para_f[5]
        return dx2, dy2

    @numba.jit
    def code_cal_dis(dx1, dx2, dy1, dy2):  # 计算两像点之间的距离
        """
        计算两点之间距离
        """
        dis = math.sqrt((dx1 - dx2) * (dx1 - dx2) + (dy1 - dy2) * (dy1 - dy2))
        return dis

    def find_in_code_point(dx_f, dy_f, limit_error=2.0):
        """
        将点换算至编码点坐标系，确认是否为编码点中的6、7、8点
        """
        pdx = [0, 15.4, 5.6, 21, 10.5, 0, 5.6, 21, 10.5, 15.4, 0, 15.4, 5.6, 21, 10.5, 30.8, 32.2, 32.2, 30.8, 30.8, 36.4, 36.4, 36.4, 36.4, 36.4, 42, 42, 42, 42, 42]
        pdy = [42, 42, 42, 42, 42, 36.4, 36.4, 36.4, 36.4, 36.4, 30.8, 32.2, 30.8, 32.2, 30.8, 5.6, 21, 15.4, 10.5, 0, 0, 5.6, 10.5, 15.4, 21, 5.6, 15.4, 21, 10.5, 0]
        # 赋值，如下坐标为设计编码标志点中编码点坐标（除了五个坐标系建立点）
        # pdx[0] = 0
        # pdy[0] = 42
        # pdx[1] = 15.4
        # pdy[1] = 42
        # pdx[2] = 5.6
        # pdy[2] = 42
        # pdx[3] = 21
        # pdy[3] = 42
        # pdx[4] = 10.5
        # pdy[4] = 42
        # pdx[5] = 0
        # pdy[5] = 36.4
        # pdx[6] = 5.6
        # pdy[6] = 36.4
        # pdx[7] = 21
        # pdy[7] = 36.4
        # pdx[8] = 10.5
        # pdy[8] = 36.4
        # pdx[9] = 15.4
        # pdy[9] = 36.4
        # pdx[10] = 0
        # pdy[10] = 30.8
        # pdx[11] = 15.4
        # pdy[11] = 32.2
        # pdx[12] = 5.6
        # pdy[12] = 30.8
        # pdx[13] = 21
        # pdy[13] = 32.2
        # pdx[14] = 10.5
        # pdy[14] = 30.8
        # pdx[15] = 30.8
        # pdy[15] = 5.6
        # pdx[16] = 32.2
        # pdy[16] = 21
        # pdx[17] = 32.2
        # pdy[17] = 15.4
        # pdx[18] = 30.8
        # pdy[18] = 10.5
        # pdx[19] = 30.8
        # pdy[19] = 0
        # pdx[20] = 36.4
        # pdy[20] = 0
        # pdx[21] = 36.4
        # pdy[21] = 5.6
        # pdx[22] = 36.4
        # pdy[22] = 10.5
        # pdx[23] = 36.4
        # pdy[23] = 15.4
        # pdx[24] = 36.4
        # pdy[24] = 21
        # pdx[25] = 42
        # pdy[25] = 5.6
        # pdx[26] = 42
        # pdy[26] = 15.4
        # pdx[27] = 42
        # pdy[27] = 21
        # pdx[28] = 42
        # pdy[28] = 10.5
        # pdx[29] = 42
        # pdy[29] = 0
        for s in range(30):
            dis = code_cal_dis(pdx[s], dx_f, pdy[s], dy_f)
            if dis < limit_error:
                return s
        return -1

    # -----8点扫描开始-------------------------------------
    # print('reading 8code…………')
    # search_area = 0.0
    search_ratio = search
    # -----------------------------------
    # IMAGE_TARGET 结构体初始化
    initial_5_code_point = list()
    final_5_code_point = list()
    initial_5_code_point_per = IMAGE_TARGET()
    final_5_code_point_per = IMAGE_TARGET()
    for i in range(150):  # 规定初始编码点数量为小于等于150个
        initial_5_code_point.append(copy.deepcopy(initial_5_code_point_per))
    for i in range(6):  # 定义一个编码点最终的5个点的list（其中为class定义的结构体）
        final_5_code_point.append(copy.deepcopy(final_5_code_point_per))
    # -------------------------------------
    with open('code.ini', 'r') as code_txt:
        code_dec = code_txt.read().split('\n')
    for i in range(target_number):  # 开始在单张像片中所有点搜索
        affine_para = [0, 0, 0, 0, 0, 0]  # 定义仿射变换参数list
        find_code = False  # “是否为最终的点”判断标志
        if target_list[i].b5code:  # 如果b5code为True，（如果是5点之一，则跳过该点，扫描下一点）
            continue
        # 开始搜索点集
        search_area = (target_list[i].width + target_list[i].height) / 2.0 * search_ratio  # 预选编码点时的搜索半径
        code_num = 0  # 在编码点搜索范围内一共搜到的点数
        initial_5_code_point[0].du = target_list[i].du
        initial_5_code_point[0].dv = target_list[i].dv
        initial_5_code_point[0].index = i
        final_5_code_point[5].du = target_list[i].du
        final_5_code_point[5].dv = target_list[i].dv
        final_5_code_point[5].index = i
        code_num += 1
        # 一定范围内搜索目标点，存于initial_5_code_point中
        for j in range(target_number):  # target_number : 所有单点个数
            if target_list[j].b5code:  # 若b5code为True，即是5标志点之一，继续循环
                continue
            if i == j:  # 如果是自身，跳过继续循环
                continue
            distance = math.sqrt(
                (target_list[i].du - target_list[j].du) * (target_list[i].du - target_list[j].du) + (
                            target_list[i].dv - target_list[j].dv) * (target_list[i].dv - target_list[j].dv))
            if distance < search_area:  # 若量点距离小于搜索半径，则放在编码点初始点集中
                if code_num >= 150:  # 原：299
                    continue
                initial_5_code_point[code_num].du = target_list[j].du
                initial_5_code_point[code_num].dv = target_list[j].dv
                initial_5_code_point[code_num].index = j
                code_num += 1
        if code_num < 8:  # 若规定搜索半径内点数小于8，则结束继续搜索其他的
            continue  # 搜到的点数不满足要求，则继续
        # 搜索出来了一个初始编码点集-----------------
        # 遍历搜到得点集中除0以外得所有点，建立直线方程
        for j in range(1, code_num):
            # da = 0.0  # y = ax + b
            # db = 0.0
            if -0.000001 < (initial_5_code_point[j].du - initial_5_code_point[0].du) < 0.000001:
                continue
            # da = (initial_5_code_point[j].dv - initial_5_code_point[0].dv) / (
            #             initial_5_code_point[j].du - initial_5_code_point[0].du)  # a = （y2 - y1） / （x2 - x1）
            # db = (initial_5_code_point[0].dv - initial_5_code_point[0].du) * da  # b = y1 - x1 * a 正确

            for k in range(1, code_num):  # 第三个点
                if k == j:
                    continue
                # line = float(
                #     initial_5_code_point[k].du * da + db - initial_5_code_point[k].dv)  # 第三个点与前两个点直线的y方向的偏差
                # 判断是否为共线其它两点的中心
                dis_i_j = math.sqrt(
                    (target_list[initial_5_code_point[0].index].du - target_list[initial_5_code_point[j].index].du)
                    * (target_list[initial_5_code_point[0].index].du - target_list[
                        initial_5_code_point[j].index].du)
                    + (target_list[initial_5_code_point[0].index].dv - target_list[
                        initial_5_code_point[j].index].dv)
                    * (target_list[initial_5_code_point[0].index].dv - target_list[
                        initial_5_code_point[j].index].dv))
                dis_i_k = math.sqrt(
                    (target_list[initial_5_code_point[0].index].du - target_list[initial_5_code_point[k].index].du)
                    * (target_list[initial_5_code_point[0].index].du - target_list[
                        initial_5_code_point[k].index].du)
                    + (target_list[initial_5_code_point[0].index].dv - target_list[
                        initial_5_code_point[k].index].dv)
                    * (target_list[initial_5_code_point[0].index].dv - target_list[
                        initial_5_code_point[k].index].dv))
                # dis_j_k = math.sqrt(  # 没用上
                #      (target_list[initial_5_code_point[j].index.du - target_list[initial_5_code_point[k].index.du)
                #      * (target_list[initial_5_code_point[j]].index.du - target_list[initial_5_code_point[k].index.du)
                #      + (target_list[initial_5_code_point[j].index.dv - target_list[initial_5_code_point[k].index.dv)
                #      * (target_list[initial_5_code_point[j].index.dv- target_list[initial_5_code_point[k].index.dv))

                vector_quantity_i_j_x = initial_5_code_point[j].du - initial_5_code_point[0].du  # i j 两点x坐标差值
                vector_quantity_i_j_y = initial_5_code_point[j].dv - initial_5_code_point[0].dv  # i j 两点y坐标差值
                vector_quantity_i_k_x = initial_5_code_point[k].du - initial_5_code_point[0].du  # i k 两点x坐标差值
                vector_quantity_i_k_y = initial_5_code_point[k].dv - initial_5_code_point[0].dv  # i k 两点y坐标差值
                vector_angle = vector_quantity_i_j_x * vector_quantity_i_k_x + vector_quantity_i_j_y * vector_quantity_i_k_y
                vector_angle /= math.sqrt(
                    vector_quantity_i_j_x * vector_quantity_i_j_x + vector_quantity_i_j_y * vector_quantity_i_j_y)
                vector_angle /= math.sqrt(
                    vector_quantity_i_k_x * vector_quantity_i_k_x + vector_quantity_i_k_y * vector_quantity_i_k_y)
                # vector_angle = math.acos(vector_angle)
                if vector_angle < 1:  # 判断i j k 三点是否共线，若共线则vector_angle为1、或小于1（计算其共线误差，若小于限差则也共线）
                    vector_angle = math.acos(vector_angle)
                else:
                    vector_angle = math.acos(vector_angle - 1)
                vector_angle = math.degrees(vector_angle)  # 将共线角度从弧度化为度
                # print("vector_angle:", vector_angle)

                if (180.0 - vector_angle) > line_error:  # 若不共线，则进行下一个点
                    continue
                if (dis_i_j / dis_i_k - 1.5898) < 0.2:
                    if dis_i_j > dis_i_k:  # 2020.6.15改
                        final_5_code_point[1].du = initial_5_code_point[j].du
                        final_5_code_point[1].dv = initial_5_code_point[j].dv
                        final_5_code_point[1].index = initial_5_code_point[j].index

                        final_5_code_point[3].du = initial_5_code_point[k].du
                        final_5_code_point[3].dv = initial_5_code_point[k].dv
                        final_5_code_point[3].index = initial_5_code_point[k].index
                    elif dis_i_j < dis_i_k:
                        final_5_code_point[1].du = initial_5_code_point[k].du
                        final_5_code_point[1].dv = initial_5_code_point[k].dv
                        final_5_code_point[1].index = initial_5_code_point[k].index

                        final_5_code_point[3].du = initial_5_code_point[j].du
                        final_5_code_point[3].dv = initial_5_code_point[j].dv
                        final_5_code_point[3].index = initial_5_code_point[j].index
                else:
                    continue
                # 点在中心，为5号点备选点
                # 搜索2、4号点，遍历其余所有点，m、n！=0 j k
                for m in range(1, code_num):  # 遍历搜索到的点，m点为预选2点
                    if m == j or m == k:
                        continue
                    for n in range(1, code_num):  # 遍历搜索到的点，n点为预选4点
                        if n == m or n == j or n == k:
                            continue
                        # 判断1、3号点，判断m、n两点与直线0j交点位置，位于0j区间时，j为3号点，位于0k区间时，k为3号点
                        # lmn_a = 0.0  # y = ax + b
                        # lmn_b = 0.0
                        if -0.000001 < (initial_5_code_point[m].du - initial_5_code_point[n].du) < 0.000001:
                            continue

                        # # ------------------------------------------------------------------------------------------
                        # lmn_a = (initial_5_code_point[m].dv - initial_5_code_point[n].dv) / (
                        #             initial_5_code_point[m].du - initial_5_code_point[n].du)
                        # lmn_b = initial_5_code_point[m].dv - initial_5_code_point[m].du * da
                        # intersection_x = (lmn_b - db) / (da - lmn_a)  # 未用到
                        # intersection_y = da * initial_5_code_point[m].du + db  # 未用到
                        # --------------------------------------------------------------------------------------------------
                        # 判断2、4号点，根据y向量13判断，2号点位于向量右侧，4号点位于向量左侧
                        # 向量13
                        vector_13_x = final_5_code_point[3].du - final_5_code_point[1].du
                        vector_13_y = final_5_code_point[3].dv - final_5_code_point[1].dv
                        # 与13垂直的单位向量
                        vector_vertical_13_x = 1
                        vector_vertical_13_y = - vector_13_x / vector_13_y
                        if vector_13_y > 0:
                            vector_vertical_13_x *= -1
                            vector_vertical_13_y *= -1
                        # 向量1m
                        vector_1_m_x = initial_5_code_point[m].du - final_5_code_point[1].du
                        vector_1_m_y = initial_5_code_point[m].dv - final_5_code_point[1].dv
                        # 向量1m与垂直单位向量内积
                        inner_product = vector_1_m_x * vector_vertical_13_x + vector_1_m_y * vector_vertical_13_y

                        # 判断inner_product，如果大于0，m在向量右侧，即m为2号点，n为4号点，否则交换两点
                        if inner_product > 0.0:
                            final_5_code_point[2].du = copy.deepcopy(initial_5_code_point[m].du)
                            final_5_code_point[2].dv = copy.deepcopy(initial_5_code_point[m].dv)
                            final_5_code_point[2].index = copy.deepcopy(initial_5_code_point[m].index)
                            final_5_code_point[2].code_num = 2  # 2020.6.17

                            final_5_code_point[4].du = copy.deepcopy(initial_5_code_point[n].du)
                            final_5_code_point[4].dv = copy.deepcopy(initial_5_code_point[n].dv)
                            final_5_code_point[4].index = copy.deepcopy(initial_5_code_point[n].index)
                            final_5_code_point[4].code_num = 4  # 2020.6.17
                        else:
                            final_5_code_point[2].du = copy.deepcopy(initial_5_code_point[n].du)
                            final_5_code_point[2].dv = copy.deepcopy(initial_5_code_point[n].dv)
                            final_5_code_point[2].index = copy.deepcopy(initial_5_code_point[n].index)
                            final_5_code_point[2].code_num = 2  # 2020.6.17

                            final_5_code_point[4].du = initial_5_code_point[m].du
                            final_5_code_point[4].dv = initial_5_code_point[m].dv
                            final_5_code_point[4].index = copy.deepcopy(initial_5_code_point[m].index)
                            final_5_code_point[4].code_num = 4  # 2020.6.17
                        # 计算交比
                        a1 = (final_5_code_point[4].dv - final_5_code_point[2].dv) / (
                                    final_5_code_point[4].du - final_5_code_point[2].du)
                        b1 = final_5_code_point[4].dv - a1 * final_5_code_point[4].du
                        a2 = (final_5_code_point[3].dv - final_5_code_point[1].dv) / (
                                    final_5_code_point[3].du - final_5_code_point[1].du)
                        b2 = final_5_code_point[3].dv - a2 * final_5_code_point[3].du
                        # print('(a1 - a2):', (a1 - a2))
                        if (a1 - a2) == 0:
                            a1 += 0.000001
                        x_24 = (b2 - b1) / (a1 - a2)  # 直线24与13交点x坐标
                        y_24 = a1 * x_24 + b1  # 直线24与13交点y坐标

                        lac_x = final_5_code_point[3].du - final_5_code_point[5].du  # 3--5
                        lbd_x = x_24 - final_5_code_point[1].du  # 2-4-1
                        lad_x = final_5_code_point[3].du - final_5_code_point[1].du  # 3--1
                        lbc_x = x_24 - final_5_code_point[5].du  # 2-4-5

                        lac_y = final_5_code_point[3].dv - final_5_code_point[5].dv  # 3--5
                        lbd_y = y_24 - final_5_code_point[1].dv  # 2-4-1
                        lad_y = final_5_code_point[3].dv - final_5_code_point[1].dv  # 3--1
                        lbc_y = y_24 - final_5_code_point[5].dv  # 2-4-5
                        # 交比
                        # print('(lad_x * lbc_x + lad_y * lbc_y):', (lad_x * lbc_x + lad_y * lbc_y))
                        cross_ratio = (lac_x * lbd_x + lac_y * lbd_y) / (lad_x * lbc_x + lad_y * lbc_y)
                        # 理论交比赋值
                        code_cross_ratio = 1.51

                        if -cross_error < (cross_ratio - code_cross_ratio) < cross_error:
                            # affine_p = [0, 0, 0, 0, 0, 0]  # 定义仿射变换参数

                            back, affine_error1, affine_p = affine_8_code_error(final_5_code_point)
                            if -affine_error < affine_error1 < affine_error:  # 若计算出的仿射变换误差小于仿射变换误差阈值，则五点找到

                                affine_para[0] = affine_p[0][0]
                                affine_para[1] = affine_p[1][0]
                                affine_para[2] = affine_p[2][0]
                                affine_para[3] = affine_p[3][0]
                                affine_para[4] = affine_p[4][0]
                                affine_para[5] = affine_p[5][0]

                                # print(final_5_code_point[1].index,
                                #       final_5_code_point[2].index,
                                #       final_5_code_point[3].index,
                                #       final_5_code_point[4].index,
                                #       final_5_code_point[5].index)

                                target_list[final_5_code_point[1].index].code_num = 1
                                target_list[final_5_code_point[2].index].code_num = 2
                                target_list[final_5_code_point[3].index].code_num = 3
                                target_list[final_5_code_point[4].index].code_num = 4
                                target_list[final_5_code_point[5].index].code_num = 5  # 以上没毛病，成功识别出来5点

                                target_list[final_5_code_point[1].index].b5code = True
                                target_list[final_5_code_point[2].index].b5code = True
                                target_list[final_5_code_point[3].index].b5code = True
                                target_list[final_5_code_point[4].index].b5code = True
                                target_list[final_5_code_point[5].index].b5code = True

                                target_list[final_5_code_point[1].index].b_code = True
                                target_list[final_5_code_point[2].index].b_code = True
                                target_list[final_5_code_point[3].index].b_code = True
                                target_list[final_5_code_point[4].index].b_code = True
                                target_list[final_5_code_point[5].index].b_code = True

                                target_list[final_5_code_point[5].index].code_center = True
                                j = k = m = n = code_num
                                find_code = True
                                continue
                    # n循环结束（4号点备选点）
                # m循环结束（2号点备选点）
            # k循环结束（3号点）
        # j循环结束（1号点）

        if find_code:  # 如果五点识别完毕，则进行识别其余点
            # find_no678 = False
            j = 0
            sign_index = 0
            bin_code = [0 for b in range(30)]  # 编码点30个（6、7、8）点的分布
            find_sign = [0 for z in range(code_num)]
            for j in range(code_num):
                if target_list[initial_5_code_point[j].index].b5code:
                    continue
                dx, dy = affine(initial_5_code_point[j], affine_para)  # 仿射变换，将坐标变换至设计值下
                # print('dx:', dx, 'dy:', dy)
                find_code_back = find_in_code_point(dx, dy)  # 由在编码点坐标系中的坐标值得出点对应的点号（若不在规定点位置则返回-1）
                if find_code_back > 0:
                    bin_code[find_code_back] = 1
                    find_sign[j] = 1
            code_no = code_bin_to_dec(bin_code, 30)
            if code_no == 0:
                continue
            for f in range(505):
                if code_no == int(code_dec[f]):
                    code_no = f + 1
                    # print('code_no:', code_no)
                    break
            if code_no == 505 or code_no == 0 or code_no > 505:
                j = code_num
                # find_no678 = False
                target_list[final_5_code_point[1].index].code_num = -1
                target_list[final_5_code_point[2].index].code_num = -1
                target_list[final_5_code_point[3].index].code_num = -1
                target_list[final_5_code_point[4].index].code_num = -1
                target_list[final_5_code_point[5].index].code_num = -1

                target_list[final_5_code_point[1].index].b5code = False
                target_list[final_5_code_point[2].index].b5code = False
                target_list[final_5_code_point[3].index].b5code = False
                target_list[final_5_code_point[4].index].b5code = False
                target_list[final_5_code_point[5].index].b5code = False

                target_list[final_5_code_point[1].index].b_code = False
                target_list[final_5_code_point[2].index].b_code = False
                target_list[final_5_code_point[3].index].b_code = False
                target_list[final_5_code_point[4].index].b_code = False
                target_list[final_5_code_point[5].index].b_code = False
                continue
            index = 6
            for f in range(code_num):  # 陆续添加6、7、8点名
                if find_sign[f]:
                    target_list[initial_5_code_point[f].index].screen_name = '{}{}_{}'.format(SETTING_PARAMETER.code_prefix_name, str(code_no), str(index))
                    target_list[initial_5_code_point[f].index].match_num = 10000 + code_no * 10 + index
                    target_list[initial_5_code_point[f].index].code_name = code_no
                    target_list[initial_5_code_point[f].index].code_num = index
                    target_list[initial_5_code_point[f].index].b5code = True
                    index += 1  # index就是应该在这，不是在前面

            # # -----------------------------------------------------2020.6.15新增
            # 赋予点所属的编码点号(.code_name)
            target_list[final_5_code_point[1].index].code_name = code_no
            target_list[final_5_code_point[2].index].code_name = code_no
            target_list[final_5_code_point[3].index].code_name = code_no
            target_list[final_5_code_point[4].index].code_name = code_no
            target_list[final_5_code_point[5].index].code_name = code_no
            # print("code_name:", code_no)
            # # ------------------------------------------------------

            target_list[final_5_code_point[1].index].match_num = 10000 + code_no * 10 + 1
            target_list[final_5_code_point[2].index].match_num = 10000 + code_no * 10 + 2
            target_list[final_5_code_point[3].index].match_num = 10000 + code_no * 10 + 3
            target_list[final_5_code_point[4].index].match_num = 10000 + code_no * 10 + 4
            target_list[final_5_code_point[5].index].match_num = 1000 + code_no
            # find_no678 = True

            target_list[final_5_code_point[1].index].screen_name = '{}{}_{}'.format(SETTING_PARAMETER.code_prefix_name, str(code_no), str(
                target_list[final_5_code_point[1].index].code_num))
            target_list[final_5_code_point[2].index].screen_name = '{}{}_{}'.format(SETTING_PARAMETER.code_prefix_name, str(code_no), str(
                target_list[final_5_code_point[2].index].code_num))
            target_list[final_5_code_point[3].index].screen_name = '{}{}_{}'.format(SETTING_PARAMETER.code_prefix_name, str(code_no), str(
                target_list[final_5_code_point[3].index].code_num))
            target_list[final_5_code_point[4].index].screen_name = '{}{}_{}'.format(SETTING_PARAMETER.code_prefix_name, str(code_no), str(
                target_list[final_5_code_point[4].index].code_num))
            target_list[final_5_code_point[5].index].screen_name = '{}{}'.format(SETTING_PARAMETER.code_prefix_name, str(code_no))
            # print("final_5_code_point[2].index:", final_5_code_point[2].index)
            # print("target_list[final_5_code_point[2].index].screen_name:",
            #       target_list[final_5_code_point[2].index].screen_name)
            # print("final_5_code_point[4].index:", final_5_code_point[4].index)
            # print("target_list[final_5_code_point[4].index].screen_name:",
            #       target_list[final_5_code_point[4].index].screen_name)
    return 1, target_list

# 扫描图像
# @numba.jit(nopython=True)
def scan_img(img_array):  # 扫描图像
    """扫描图像函数，调用单行扫描函数、多行扫描函数、行合并函数、编码点识别函数"""
    Image_Target_f = []
    # print('img_width:', img_width, 'img_height:', img_height)  # 打印图像尺寸
    # 扫描图片所有行，获得行片段索引
    row_index = scan_all_row(img_array, SCAN_PARAMETER.grid_threshold, SCAN_PARAMETER.width_max_limit,
                             SCAN_PARAMETER.width_min_limit, SCAN_PARAMETER.brightness)
    # 合并所有行片段，返回点列表
    target_num, target_list = merge_rows(row_index)  # 返回点的个数，点片段集合
    Target_Index = ['' for i in range(target_num)]
    target_list = copy.deepcopy(target_list[:target_num])
    # 开始一个点一个点遍历处理
    for target_index in range(len(target_list)):
        # print('正在处理第{}个标志点……'.format(target_index + 1))
        one_target = TARGET_ASSEMBLY()  # 用类替代c++中的结构体
        if one_target == 0:
            continue
        one_target.du = 0.0  # du
        one_target.dv = 0.0  # dv
        pix_num = 0  # 标志点像素数
        perimeter = 0  # 周长
        over_exposure_pix_num = 0  # 过度曝光像素数目
        left = img_array.shape[1]  # 标志点最外围四个像素数的位置
        right = 0
        top = img_array.shape[0]
        bottom = 0
        row_gray_sum_sqr = 0.0
        coll_gray_sum_sqr = 0.0
        weight = 0.0  # 一个点的所有灰度加权平方和平均值
        segment_num = len(target_list[target_index])  # 单个标志点片段数目

        for segment_index in range(segment_num):
            # print('正在处理第{}个标志点中的第{}个片段……'.format(target_index, segment_index))
            start = target_list[target_index][segment_index].start  # 单个片段的属性
            end = target_list[target_index][segment_index].end
            row = target_list[target_index][segment_index].row
            for segment_pos in range(start, end + 1):  # 遍历片段中的所有元素
                if img_array[row][segment_pos] > SCAN_PARAMETER.grid_threshold:
                    if one_target.max_gray < img_array[row][segment_pos]:  # [8] max_gray
                        one_target.max_gray = img_array[row][segment_pos]  # [8] max_gray
                    weight += int(img_array[row][segment_pos]) * int(img_array[row][segment_pos])  # 权重值累加
                    row_gray_sum_sqr += segment_pos * img_array[row][segment_pos] * img_array[row][
                        segment_pos]  # 行加权求和  [3] du
                    coll_gray_sum_sqr += row * img_array[row][segment_pos] * img_array[row][
                        segment_pos]  # 列加权求和  [4] dv

                # 统计曝光像素数目
                if img_array[row][segment_pos] == 255:
                    over_exposure_pix_num += 1

                # 统计标志点最外围四个像素
                if left > start:
                    left = start
                if right < end:
                    right = end
                if top > row:
                    top = row
                if bottom < row:
                    bottom = row

                # 统计标志点像素数目
                pix_num += 1

            # 统计周长
            if target_index == 0:
                if segment_num == 1:
                    perimeter = 2 * pix_num + 2
                else:
                    perimeter += end - start + 1
            else:
                last_index = target_list[target_index][segment_index - 1]
                perimeter += abs(end - last_index.end) + 1.0
                perimeter += abs(start - last_index.start) + 1.0
                if segment_index == segment_num - 1:
                    perimeter += end - start + 1

        if pix_num == 0:
            continue
        # 计算标志点中心
        if weight > 0.000000001:
            one_target.du = row_gray_sum_sqr / weight  # 更新du
            one_target.dv = coll_gray_sum_sqr / weight  # 更新dv
            # print('标志点{}中心坐标为x={}，y={}'.format(target_index, one_target[3], one_target[4]))
            # print('标志点{}最大灰度值：'.format(target_index), one_target[8])
        # 计算标志点宽高
        one_target.width = right - left + 1  # 标志点width
        one_target.height = bottom - top + 1  # 标志点height
        # 计算标志圆度
        area = pix_num + 1
        one_target.shape = float(area / (perimeter * perimeter)) * 4.0 * 3.141593  # 圆形度计算
        # 计算黑白比
        one_target.black_white = (pix_num + 1.0) / float(
            one_target.width * one_target.height)
        # 计算过度曝光率
        one_target.over_exposure = over_exposure_pix_num / float(pix_num)
        # 标志点像素数
        one_target.pix_num = pix_num + 1

        # 过度曝光剔除
        if one_target.over_exposure > float(SCAN_PARAMETER.over_exposure):
            one_target.value = False
            # print('剔除原因：过度曝光剔除', target_index)
            continue
        # 宽高剔除
        if one_target.height < SCAN_PARAMETER.height_min_limit or one_target.height > SCAN_PARAMETER.height_max_limit:
            one_target.value = False
            # print('剔除原因：宽剔除', target_index)
            continue
        if one_target.width < SCAN_PARAMETER.width_min_limit or one_target.width > SCAN_PARAMETER.width_max_limit:
            one_target.value = False
            # print('剔除原因：高剔除', target_index)
            continue
        # 黑白比剔除
        if one_target.black_white < SCAN_PARAMETER.black_white_min_limit or one_target.black_white > SCAN_PARAMETER.black_white_max_limit:
            one_target.value = False
            continue
        # 圆形度剔除
        if one_target.shape < SCAN_PARAMETER.shape:
            one_target.value = False
            # print('剔除原因：圆形度剔除', target_index)
            continue
        # 像素数目剔除
        if one_target.pix_num < SCAN_PARAMETER.pix_num_min_limit or one_target.pix_num > SCAN_PARAMETER.pix_num_max_limit:
            one_target.value = False
            # print('剔除原因：像素数目剔除', target_index)
            continue

        single_image_target = IMAGE_TARGET()
        if one_target.value:
            single_image_target.width = one_target.width  # 像点width赋值
            single_image_target.height = one_target.height  # 像点height赋值
            single_image_target.du = one_target.du  # 像点du赋值==本程序所用坐标系与常规摄影测量坐标系相反，因此需注意反向使用坐标系==
            single_image_target.dv = one_target.dv  # 像点dv赋值==因此计算完成之后需要将像点坐标得x与y值相颠倒==
            Image_Target_f.append(single_image_target)

        Target_Index[target_index] = one_target
    # 编码点识别
    comfirm, Image_Target = read_8_code(Image_Target_f, len(Image_Target_f), SETTING_PARAMETER.search_parameter,
                                        SETTING_PARAMETER.line_error, SETTING_PARAMETER.cross_error,
                                        SETTING_PARAMETER.affine_error)
    return Image_Target


def scan_single_img():
    """单个图像扫描程序调用"""

    time1 = time.time()
    img_num = w.img_list.curselection()[0]  # 选定的listbox中的像片，返回像片的序号
    img_1 = imgs[img_num]  # 调出imgs中对应的像片
    img_1.targets = False
    w.Canvas1.delete('text')  # 清空此时画布中的所有text
    w.Scrolledtext1.insert('end', '正在扫描第{}张图像……\n'.format(str(w.img_list.curselection()[0] + 1)))
    # -------------------缩放图像至合适大小并显示至画布中-------------------
    resized_img = resize_img(1202, 675, (img_1.img).convert('L'))
    photo = ImageTk.PhotoImage(resized_img)  # 利用PIL模块的PhotoImage打开
    w.Canvas1.create_image(0, 0, anchor='nw', image=photo, tag='text')
    # --------若图像已经扫描，则显示text，若没有被扫描，则扫描并显示text-------
    if img_1.targets:
        draw_point_center(img_1.img, img_1.targets)
    else:
        single_img_targets = scan_img(pylab.array(img_1.img.convert('L')))
        imgs[img_num].targets = single_img_targets
        draw_point_center(img_1.img, single_img_targets)
    w.menu.entryconfig(1, state='normal')  # 使得图像像点畸变纠正 按键有效
    w.menu.entryconfig(2, state='normal')
    w.menu.entryconfig(3, state='normal')
    time2 = time.time()
    w.Scrolledtext1.insert('end', '图像扫描耗时：{:.2f}s\n'.format((time2 - time1)))
    w.Canvas1.mainloop()  # 一定要加循环，否则图片在画布上显示不出来

def scan_all_imgs():
    """扫描图像"""
    # -------------导入 time 模块计算扫描时间--------------
    import time
    import datetime
    time1 = time.time()
    # ------------------判断是否含有图像-------------------
    print('IPG_GUI_support.scan_imgs')
    if len(imgs) == 0:
        messagebox.showinfo('tip', '没有导入图像！')
    # --------------------扫描图像循环------------------------
    for i in range(len(imgs)):
        imgs[i].targets = False
        print('第{}张图像扫描中……\n'.format(i + 1))
        imgs[i].targets = scan_img(pylab.array(imgs[i].img.convert('L')))
        print('第{}张图像扫描完成！\n'.format(i + 1))
    all_img_point_correct()  # 像点坐标改正
    # -------------------------------------------------
    time2 = time.time()
    scan_time = datetime.timedelta(seconds=(time2 - time1))  # 计算图像扫描时间
    # ------------------激活扫描图像完成可触发的控件--------------------
    w.Scrolledtext1.insert('end', '图像扫描完成！共耗时{},共扫描{}张\n'.format(str(scan_time), len(imgs)))
    w.menu.entryconfig(1, state='normal')
    w.menu.entryconfig(2, state='normal')
    w.menu.entryconfig(3, state='normal')
    w.sub_menu1.entryconfig(7, state='normal')  # 使’导出所有像点坐标选项‘变可点击
    # ------------全部扫描完之后，更新并显示画布上图像的点以及编码点-----------------
    try:
        img_num = w.img_list.curselection()[0]  # 选定的listbox中的像片，返回像片的序号
        img_1 = imgs[img_num]  # 调出imgs中对应的像片
        if img_1.targets:
            draw_point_center(img_1.img, img_1.targets)
        else:
            single_img_targets = scan_img(pylab.array(img_1.img.convert('L')))
            imgs[img_num].targets = single_img_targets
            draw_point_center(img_1.img, single_img_targets)
    except IndexError:
        pass
    # -----------------------------------------------------------------------

def match_points():
    """图像匹配"""
    print('IPG_GUI_support.match_points')
    sys.stdout.flush()

def open_file():
    """打开测量工程"""
    print('IPG_GUI_support.open_file')
    sys.stdout.flush()

def orentation():
    """定向获取外方位元素与物方点初值"""
    print('IPG_GUI_support.orentation')
    sys.stdout.flush()

def bundle_adjustment_setting():
    """光束法平差设置"""
    print('IPG_GUI_support.bundle_adjustment_setting')
    sys.stdout.flush()

def match_setting():
    """像点匹配设置"""
    print('IPG_GUI_support.match_setting')
    sys.stdout.flush()

def scan_setting():
    """单点扫描设置"""
    print('IPG_GUI_support.single_pt_scan_setting')
    import scan_setting_win_support
    scan_setting_win_support.main_start()

def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None


if __name__ == '__main__':
    import IPG_GUI
    IPG_GUI.vp_start_gui()







